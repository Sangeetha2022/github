
import { Request, response } from 'express';
import * as simplegit from 'simple-git/promise';
import * as request from "request-promise-native";
import { GithubConfig } from '../config/GithubConfig';
import { Octokit } from '@octokit/core'

const sodium = require('tweetsodium');

let git = null;
let commitTo = 'GitHub';
//const octokit = new Octokit({ auth: process.env.PrivategitPassword });




export class PrivateGitHubService {
    private secrets;

    checkIfRepoExist = (req: Request, callback: CallableFunction) => {


        const details = req.body;
        const path = `${details.codeGenerationPath}`;
        git = simplegit(`${details.codeGenerationPath}`);
        let creds = {};
        try {
            git.checkIsRepo().then((status) => {
                this.githubCreds((credentials) => {
                    creds = {
                        username: credentials.PrivategitUsername,
                        password: credentials.PrivategitPassword,
                        email: credentials.PrivategitEmail
                    }

                    if (!status && commitTo.toLocaleLowerCase() === 'github') {
                        this.createRepoInGitHub(creds, details, callback)
                    } else {
                        this.updateGitRepo(creds, callback)
                    }
                })
            })
        } catch (err) {
            callback('cannot able to push the code in github');
        }
    }

    private githubCreds(callback) {
        let gConfig = new GithubConfig();
        gConfig.githubPrivateConfig(function(credentials) {
            callback(credentials);
        });
    }

    private createRepoInGitHub = async (creds, details, callback) => {
        let gitBody = {
            "name": details.project_unique_id,
            "description": "Generated by Geppetto",
            "homepage": "",
            "private": true,
            "has_issues": true,
            "has_projects": true,
            "has_wiki": true
        }

        let USER = creds.username;
        let PASS = creds.password;
        let reponame = details.project_unique_id;
        let remote = `https://${USER}:${PASS}@api.github.com/user/repos`
        let config_url = `https://${USER}:${PASS}@github.com/${USER}/${reponame}`
        await request({
            uri: remote,
            method: "POST",
            json: gitBody,
            headers: {
                'User-Agent': "https://api.github.com/meta",
                'Content-Type': 'application/json'
            }
        }).then((resp) => {
            this.initializeGitAndPushToSource(config_url, creds, callback)
        }).catch((err) => {
            callback(err.error.message)
        })
        const octokit = new Octokit({ auth: PASS });
        const publicKeyResponse = await octokit.request(`GET /repos/${USER}/${reponame}/actions/secrets/public-key`);
        const publicKey = publicKeyResponse.data.key;
        const publicKeyId = publicKeyResponse.data.key_id;
        let gConfig = new GithubConfig();
        // gConfig.githubPrivateConfig(function (credentials) {
        // });
        this.githubCreds((credentials) => {
            Object.keys(credentials).forEach(function (secrets) {
            const octokit = new Octokit({ auth: credentials.PrivategitPassword });
            const key = publicKey;
            const value = credentials[secrets];    
            const messageBytes = Buffer.from(value);
            const keyBytes = Buffer.from(key, 'base64');
            const encryptedBytes = sodium.seal(messageBytes, keyBytes);
            const encrypted = Buffer.from(encryptedBytes).toString('base64');
             octokit.request(`PUT /repos/${USER}/${reponame}/actions/secrets/${secrets}`, {
                owner: USER,
                repo: reponame,
                secret_name: secrets,
                key_id: publicKeyId,
                encrypted_value: encrypted
            })
            });
        })

    }

    private initializeGitAndPushToSource = (config_url, creds, callback) => {
        git.init().then(() => {
            return git.add('.')
        }).then(() => {
            return git.addConfig('user.name', creds.username)
        }).then(() => {
            return git.addConfig('user.email', creds.email)
        }).then(() => {
            return git.commit("code commited from geppetto!")
        }).then(() => {
            return git.addRemote('origin', config_url)
        }).then(() => {
            return git.push('origin', 'master');
        }).then(() => {
            return git.checkoutLocalBranch('geppetto');
        }).then(() => {
            return git.add('.')
        }).then(() => {
            return git.push(['-u', 'origin', 'geppetto']);
        }).then((status) => {
            callback("Git Init And Pushed to New Repo.")
        })
    }

    private updateGitRepo = (creds, callback) => {
        git.add('.').then(() => {
            return git.addConfig('user.name', creds.username)
        }).then(() => {
            return git.addConfig('user.email', creds.username)
        }).then(() => {
            return git.commit("updated generated code")
        }).then(() => {
            return git.push('origin', 'geppetto');
        }).then((status) => {
            callback("Git code updated with new changes.")
        })
    }
}
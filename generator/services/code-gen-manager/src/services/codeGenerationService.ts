import { Request } from 'mongoose';
import * as asyncLoop from 'node-async-loop';
import * as fs from 'fs';
import * as util from 'util';
import * as path from 'path';

import {
  FeatureManagerService,
  FlowManagerService,
  EntityManagerService,
  BackendGenManagerService,
  MicroFlowManagerService,
  AuthGenService,
  FrontendGenManagerService,
  GithubManagerService

} from '../apiservices/index';
import { Common } from '../config/Common';
export class CodeGenerationService {

  private featureService = new FeatureManagerService();
  private entityService = new EntityManagerService();
  private backendService = new BackendGenManagerService();
  private flowService = new FlowManagerService();
  private authGenService = new AuthGenService();
  private frontendGenService = new FrontendGenManagerService();
  private githubService = new GithubManagerService();
  private NODE_PORT_NUMBER = 8000;
  private APIGATEWAY_PORT_NUMBER = 3000;
  private LOCALHOST = 'localhost';
  private APPLICATION_FOLDERNAME = 'application';
  private CLIENT_FOLDERNAME = 'client';
  private SERVICE_FOLDERNAME = 'services';
  // private DESKTOP_FOLDERNAME = 'desktop';
  // private MOBILE_FOLDERNAME = 'mobile';


  // private api
  // private microFlowService = new MicroFlowManagerService();
  // private clientObj: any = {
  //   name: '',
  //   defaultHumanLanguage: '',
  //   otherHumanLanguage: '',
  //   projectPath: '',
  //   clientLanguage: '',
  //   clientFramework: '',
  //   features: []
  // };
  // private backendObj: any = {  // private backendObj: any = {

  //   name: '',
  //   defaultHumanLanguage: '',
  //   otherHumanLanguage: '',
  //   projectPath: '',
  //   serverLanguage: '',
  //   serverFramework: '',
  //   serverDatabase: '',
  //   features: []
  // };
  // private clientArray: any[] = [];
  // private backendArray: any[] = [];
  featureDetails: any;
  private nodeResponse: any[] = [];

  public async createProject(req: Request, callback: CallableFunction) {
    const projectId = req.query.projectId;
    const projectDetails = req.body;
    const auth_templatepath = req.body.authorizationtemppath;
    console.log('--------projectdetails0-----', projectDetails);
    const gitBody = {
      name: "",
      description: "Generated by Geppetto",
      codeGenerationPath: "",
      homepage: "",
      private: false,
      has_issues: true,
      has_projects: true,
      has_wiki: true
    }
    gitBody.name = projectDetails.name;
    // const projectPath = `${projectDetails.projectGenerationPath}/${this.APPLICATION_FOLDERNAME}`;
    let projectPath = `${projectDetails.projectGenerationPath}/${projectDetails.name}`;

    gitBody.codeGenerationPath = projectPath;
    console.log('create project code rae ----- ', projectId, ' ----- ', projectDetails);
    // this.createFolders(`../../../../../generatedcode/${projectDetails.name}`);
    const isPathCreated = Common.createFolders(projectPath);
    projectPath += `/${this.APPLICATION_FOLDERNAME}`;
    Common.createFolders(projectPath);
    try {
      console.log('i am auth ******---->>', projectPath);
      const auth = await this.authGenPath(projectId, `${projectPath}/${this.SERVICE_FOLDERNAME}`,
        projectDetails.authTemplatePath, auth_templatepath).catch(error => {
          console.log('cannot able to create the auth files');
        });
      console.log('-------auth gen manager------', auth);
    } catch {
      console.log('auth generation manager microservices might be down #$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$')
    }
    console.log('path @!!!!!!!!!!!!!!!!!!!!!!! ------ ', isPathCreated);
    if (!isPathCreated) {
      return callback('code generation path may not be exist', 400);
    }
    // generate template with basic auth 
    try {
      const templateObj = {
        projectId: projectId,
        sharedUrl: this.LOCALHOST,
        apigatewayPortNumber: this.APIGATEWAY_PORT_NUMBER,
        projectGenerationPath: `${projectPath}/${this.CLIENT_FOLDERNAME}`,
        project: projectDetails
      }
      await this.frontendTemplateProject(templateObj);
    } catch {
      console.log('cannot able to create the template');
    }
    // get feature by projectId
    console.log('before getting project features ');
    const features = await this.getFeatures(projectId);
    const FeatureJSON = JSON.parse(features.toString());
    this.nodeResponse = [];
    console.log('get feature by project id are ------  ', features, '  length   ', FeatureJSON.body.length);
    if (FeatureJSON.body != undefined && FeatureJSON.body.length === 0) {
      callback('cannot able to find its features based on this project', 400);
    } else {
      try {
        asyncLoop(FeatureJSON.body, async (featureElement, next) => {

          console.log('starting feature each ovjes area--11----  ', featureElement, ' each feature length  ', featureElement.entities.length);

          const feature = {
            id: '',
            name: '',
            description: '',
            flows: [],
            entities: [],
            applicationPort: 0,
            projectGenerationPath: `${projectPath}/${this.SERVICE_FOLDERNAME}`,
            project: projectDetails
          }
          feature.id = featureElement._id;
          feature.name = featureElement.name;
          feature.description = featureElement.description;
          const flows = await this.getFlows(featureElement.flows);
          console.log('flows response rae -11----  ', flows);
          console.log('flows response rae --22---  ', JSON.parse(JSON.stringify(flows)).body);
          feature.flows = JSON.parse(JSON.stringify(flows)).body;

          if (featureElement.entities.length > 0) {
            console.log('entering into if condition 22 ');
            asyncLoop(featureElement.entities, async (featureEntity, entityNext) => {
              console.log('each feature entity ---33---  ', featureEntity);
              const entity = await this.getEntityById(featureEntity.entityId);
              console.log('each feature entity ----3.2111---  ', entity);
              feature.entities.push(JSON.parse(entity.toString()).body)
              entityNext();
            }, async (entityErr) => {
              if (entityErr) {
                console.log('entity error first ');
              } else {
                try {
                  console.log('async loop complated -44--- ', feature);
                  feature.applicationPort = this.NODE_PORT_NUMBER;
                  const backendResponse = await this.backendGenProject(feature).catch(
                    err => {
                      console.log('cannot able to geneate the backend node services');
                    }
                  );
                  this.increaseBackendPortNumber();
                  console.log('backend response in code gen -------', backendResponse);
                  console.log('backend response in code gen ------', util.inspect(backendResponse, { showHidden: true, depth: null }));
                  let temp;
                  temp = JSON.parse(JSON.stringify(backendResponse)).body.body;
                  console.log('after temp bodu bvalue are ----- ', temp);
                  // if(temp != undefined) {
                  //   console.log('entering into if conditin');
                  //   temp = temp.body;
                  // } else if (temp != undefined && temp.code == 500) {
                  //   console.log('entering into else if conditin');
                  //   callback();
                  //   // throw new Error('cannot able to get the data from node generator');
                  //   // callback(temp);
                  // } else {
                  //   console.log('entering into else conditin');
                  //   callback();
                  //   // throw new Error('cannot able to get the data from node generator');
                  //   // callback();
                  // }
                  console.log('after if executed')
                  const frontendObj = {
                    feature: feature,
                    project: projectDetails,
                    nodeResponse: null
                  }
                  if (temp != undefined && temp.length > 0) {
                    this.nodeResponse.push(temp[0]);
                    frontendObj.nodeResponse = temp[0];
                  }
                  console.log('nodeResponse for each features ----  ', util.inspect(this.nodeResponse, { showHidden: true, depth: null }));
                  //front generation manager
                  // const frontendResponse = await this.frontendGenProject(frontendObj).catch(err => {
                  //   console.log('cannot able to generate the frontend component for each screens');
                  // });
                  next();
                } catch (err1) {
                  console.log('errr111111111111111111111111');
                  console.log('errr111111111111111111111111 ---- ', err1);
                  console.error('something went wrong in code generation manager after getting the response from backend generation manager', 400);
                }
              }
            })
          } else {
            next();
          }
          console.log('ending of loop ');
        }, async (err) => {
          if (err) {
            console.log('err in loop are ---- ', err);
          } else {
            console.log('all featuers are completed ----  ', util.inspect(this.nodeResponse, { showHidden: true, depth: null }));
            // this.increaseBackendPortNumber();
            const temp = {
              projectPath: projectPath,
              applicationPort: this.APIGATEWAY_PORT_NUMBER,
              projectGenerationPath: `${projectPath}/${this.SERVICE_FOLDERNAME}`,
              project: projectDetails,
              nodeResponse: this.nodeResponse
            }
            console.log('code generation apigateway services before create gateway are ----- ', temp);
            await this.generateApiGateway(temp).catch(err => {
              console.log('cannot able to generate the api gateway node services');
            });
            await this.pushTogithub(projectId, gitBody).catch(err => {
              console.log('cannot able to push the code into github repo');
            });
            callback('code generation completed');
          }
        })
      } catch (err) {
        console.log('error in code generation manager --1111 main-- ');
        console.log('error in code generation manager ---- ', err);
        callback('something went wrong in code generation manager', 400);
      }
    }

    // callback()
  }

  pushTogithub(projectId, gitBody) {
    return new Promise(resolve => {
      console.log("codegen service-------->", projectId)
      console.log("gitBody------->", gitBody)
      this.githubService.pushProject(projectId, gitBody, (data) => {
        resolve(data);
      })
    });
  }

  getFeatures(projectId) {
    return new Promise(resolve => {
      this.featureService.getFeatureByProjectId(projectId, (data) => {
        resolve(data);
      })
    });
  }

  getFlows(flowIDs) {
    return new Promise(resolve => {
      this.flowService.getFlows(flowIDs, (data) => {
        resolve(data);
      })
    })
  }

  getFlowsByLanguage(flowIDs, language) {
    return new Promise(resolve => {
      this.flowService.getFlowsByLanguage(flowIDs, language, (data) => {
        resolve(data);
      })
    })
  }

  getEntityById(entityId) {
    return new Promise(resolve => {
      this.entityService.getEntityById(entityId, (data) => {
        resolve(data);
      })
    });
  }

  backendGenProject(details) {
    return new Promise(resolve => {
      this.backendService.BackendGenProject(details, (data) => {
        resolve(data);
      })
    })
  }

  frontendGenProject(details) {
    return new Promise(resolve => {
      this.frontendGenService.FrontendGenProject(details, (data) => {
        resolve(data);
      })
    })
  }

  frontendTemplateProject(details) {
    return new Promise(resolve => {
      this.frontendGenService.FrontendTemplateProject(details, (data) => {
        resolve(data);
      })
    })
  }

  generateApiGateway(details) {
    return new Promise(resolve => {
      this.backendService.generateApiGateway(details, (data) => {
        resolve(data);
      })
    })
  }

  authGenPath(projectId, projectGenerationPath, authPath, auth_templatepath) {
    return new Promise(resolve => {
      this.authGenService.authPath(projectId, projectGenerationPath, authPath, auth_templatepath, (data) => {
        resolve(data)
      })
    })
  }

  increaseBackendPortNumber() {
    this.NODE_PORT_NUMBER++;
  }
}